{"version":3,"file":"/jautocalc.js","mappings":"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","sources":["webpack://jautocalc/webpack/bootstrap","webpack://jautocalc/webpack/runtime/compat get default export","webpack://jautocalc/webpack/runtime/define property getters","webpack://jautocalc/webpack/runtime/hasOwnProperty shorthand","webpack://jautocalc/external var \"jQuery\"","webpack://jautocalc/./src/utils.ts","webpack://jautocalc/./src/parse.ts","webpack://jautocalc/./src/autocalc.ts","webpack://jautocalc/./src/admin.ts","webpack://jautocalc/./src/functions.ts","webpack://jautocalc/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = jQuery;","import $ from 'jquery';\nimport {IField, INumberFormat, IOptions} from './interfaces';\n\n/**\n *\n * @param eq {string} equation\n * @returns {IField[]} field names in equation or empty list\n */\nexport function findFields(eq: string): IField[] {\n    const fields: IField[] = [];\n    const r = /{([^}]+)}/gi;\n    let m: RegExpMatchArray;\n\n    while ((m = r.exec(eq)) != null) {\n    \tconst field: IField = {\n    \t\teqName: m[1],\n    \t\tfieldName: m[1],\n\t\t\treactive: true,\n\t\t};\n\n    \tif (field.fieldName[0] === '!') {\n    \t\tfield.reactive = false;\n    \t\tfield.fieldName = field.fieldName.substr(1);\n\t\t}\n        fields.push(field);\n    }\n\n    return fields;\n}\n\n/**\n *\n * @param field {string} field name\n * @returns {string} jquery input selector\n */\nexport function getFieldSelector(field: string): string {\n    if (/^[a-zA-Z].*/.test(field)) {\n        return ':input[name=\"' + field + '\"]';\n    }\n    return field;\n}\n\n/**\n *\n * @param value {string | number | string[]} field value from input control\n * @param opts {IOptions} options to decide decimal and thousands separators\n * @param numberFormat {INumberFormat} formatted values to be used later\n */\nexport function numCleanse(value: string | number | string[], opts: IOptions, numberFormat: INumberFormat): string {\n    const fieldValue = value + '';\n    const sepOpts = opts.decimalOpts.concat(opts.thousandOpts);\n    const numOpts = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-'];\n    let numValue = '';\n    let ch = '';\n    let dec = '';\n    let decLoc = -1;\n    let thou = '';\n    let sym = '';\n    let symLoc = -1;\n    let decPlaces = 0;\n\n    for (let z = fieldValue.length - 1; z >= 0; z--) {\n        ch = fieldValue.charAt(z);\n        if ($.inArray(ch, numOpts) != -1) {\n            numValue = ch + numValue;\n        } else {\n            if (dec == '' && $.inArray(ch, opts.decimalOpts) != -1) {\n                decLoc = z;\n                dec = ch;\n                numValue = '.' + numValue;\n            } else if (thou == '' && $.inArray(ch, opts.thousandOpts) != -1) {\n                thou = ch;\n            } else if (sym == '' && $.inArray(ch, sepOpts) == -1 && (z == 0 || z == fieldValue.length - 1)) {\n                sym = ch;\n                symLoc = z;\n            }\n        }\n    }\n\n    if (dec != '') {\n        decPlaces = fieldValue.length - decLoc - 1;\n        if (symLoc > decLoc) {\n            decPlaces--;\n        }\n    }\n\n    if (opts.decimalPlaces != -1) {\n        decPlaces = opts.decimalPlaces;\n    }\n\n    if (arguments.length === 3) {\n        if (numberFormat.dec == '' && dec != '') {\n            numberFormat.dec = dec;\n        }\n\n        if ((numberFormat.decPlaces == -1 && decPlaces != -1) ||\n            (numberFormat.decPlaces != -1 && decPlaces != -1 && decPlaces < numberFormat.decPlaces)) {\n            numberFormat.decPlaces = decPlaces;\n        }\n\n        if (numberFormat.thou == '' && thou != '') {\n            numberFormat.thou = thou;\n        }\n        if (numberFormat.sym == '' && sym != '') {\n            numberFormat.sym = sym;\n            numberFormat.symLoc = symLoc;\n        }\n    }\n\n    if (opts.emptyAsZero && numValue == '') {\n        numValue = '0';\n    }\n    return numValue;\n}\n\n/*\n    Takes a numeric value, \"fixes\" it to the specified number of decimal places, and then formats for typical\n    US format (\",\" for thousands and \".\" for decimal)\n*/\nexport function numberFix(num: number, decPlaces: number): string {\n    const n = num.toFixed(decPlaces) + '';\n    const x = n.split('.');\n    const x2 = x.length > 1 ? '.' + x[1] : '';\n    const rgx = /(\\d+)(\\d{3})/;\n    let x1 = x[0];\n    while (rgx.test(x1)) {\n        x1 = x1.replace(rgx, '$1' + ',' + '$2');\n    }\n    return x1 + x2;\n}\n","/*\n    Begin parse functions\n    Taken from\n        * http://stackoverflow.com/questions/28256/equation-expression-parser-with-precedence\n        * http://users.telenet.be/bartl/expressionParser/expressionParser.html\n*/\nimport { IData, IOperation, IOperations, IVars, IOptions } from './interfaces';\n\nconst ops: IOperations = {\n    '+': {\n        op: '+',\n        precedence: 10,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l + r;\n        }\n    },\n    '-': {\n        op: '-',\n        precedence: 10,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l - r;\n        }\n    },\n    '*': {\n        op: '*',\n        precedence: 20,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l * r;\n        }\n    },\n    '/': {\n        op: '/',\n        precedence: 20,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l / r;\n        }\n    },\n    '**': {\n        op: '**',\n        precedence: 30,\n        assoc: 'R',\n        exec: function (l: number, r: number) {\n            return Math.pow(l, r);\n        }\n    }\n};\n\nexport const vars: IVars = {\n    e: Math.exp(1),\n    pi: Math.atan2(1, 1) * 4\n};\n\nfunction parseVal(r: IData): number {\n    const startOffset: number = r.offset;\n    let value: number;\n    let match: RegExpMatchArray;\n    // floating point number\n    // example of parsing (\"lexing\") without aid of regular expressions\n    value = 0;\n    while ('0123456789'.indexOf(r.string.substr(r.offset, 1)) >= 0 && r.offset < r.string.length) {\n        r.offset++;\n    }\n    if (r.string.substr(r.offset, 1) == '.') {\n        r.offset++;\n        while ('0123456789'.indexOf(r.string.substr(r.offset, 1)) >= 0 && r.offset < r.string.length) {\n            r.offset++;\n        }\n    }\n    if (r.offset > startOffset) { // did that work?\n        // OK, so I'm lazy...\n        return parseFloat(r.string.substr(startOffset, r.offset - startOffset));\n    } else if (r.string.substr(r.offset, 1) == '+') { // unary plus\n        r.offset++;\n        return parseVal(r);\n    } else if (r.string.substr(r.offset, 1) == '-') { // unary minus\n        r.offset++;\n        return negate(parseVal(r));\n    } else if (r.string.substr(r.offset, 1) == '(') { // expression in parens\n        r.offset++; // eat \"(\"\n        value = parseExpr(r);\n        if (r.string.substr(r.offset, 1) == ')') {\n            r.offset++;\n            return value;\n        }\n        r.error = \"Parsing error: ')' expected\";\n        throw new Error('parseError');\n    } else if ((match = /^[a-z_][a-z0-9_]*/i.exec(r.string.substr(r.offset))) != null) { // variable/constant name\n        // sorry for the regular expression, but I'm too lazy to manually build a varname lexer\n        const name = match[0]; // matched string\n        r.offset += name.length;\n        if (name in vars) {\n            return vars[name]; // I know that thing!\n        }\n        r.error = \"Semantic error: unknown variable '\" + name + \"'\";\n        throw new Error('unknownVar');\n    } else {\n        if (r.string.length == r.offset) {\n            r.error = 'Parsing error at end of string: value expected';\n            throw new Error('valueMissing');\n        } else {\n            r.error = \"Parsing error: unrecognized value\";\n            throw new Error('valueNotParsed');\n        }\n    }\n}\n\nfunction negate(value: number): number {\n    return -value;\n}\n\nfunction parseOp(r: IData) {\n    if (r.string.substr(r.offset, 2) == '**') {\n        r.offset += 2;\n        return ops['**'];\n    }\n    if ('+-*/'.indexOf(r.string.substr(r.offset, 1)) >= 0) {\n        return ops[r.string.substr(r.offset++, 1)];\n    }\n    return null;\n}\n\nfunction parseExpr(r: IData) {\n    const stack: IOperation[] = [{\n        precedence: 0,\n        assoc: 'L'\n    }];\n    let value = parseVal(r); // first value on the left\n    for (; ;) {\n        const op = parseOp(r) || {\n            precedence: 0,\n            assoc: 'L'\n        };\n        while (op.precedence < stack[stack.length - 1].precedence ||\n            (op.precedence == stack[stack.length - 1].precedence && op.assoc == 'L')) {\n            // precedence op is too low, calculate with what we've got on the left, first\n            const tos = stack.pop();\n            if (!tos.exec) {\n                return value; // end  reached\n            }\n            // do the calculation (\"reduce\"), producing a new value\n            value = tos.exec(tos.value, value);\n        }\n        // store on stack and continue parsing (\"shift\")\n        stack.push({\n            op: op.op,\n            precedence: op.precedence,\n            assoc: op.assoc,\n            exec: op.exec,\n            value: value\n        });\n        value = parseVal(r); // value on the right\n    }\n}\n\nexport function parse(str: string, opts: IOptions): number | null {\n    const r: IData = {\n        string: str,\n        offset: 0\n    };\n    try {\n        const value = parseExpr(r);\n        if (r.offset < r.string.length) {\n            r.error = 'Syntax error: junk found at offset ' + r.offset;\n            throw new Error('trailingJunk');\n        }\n        return value;\n    } catch (e) {\n        if (opts.showParseError) {\n            alert(`${r.error} (${e}):\\n${r.string.substr(0, r.offset)}<*>${r.string.substr(r.offset)}`);\n        }\n        return null;\n    }\n}\n","import { parse } from './parse';\nimport {INumberFormat, IOptions, IVars, IFunctions, IField} from './interfaces';\nimport { getFieldSelector, numCleanse, numberFix } from './utils';\n\n/*\n    Heart of the plugin:\n        * replaces aggregate functions in the equation string with the result of the aggregate function\n            (stripped to digits, decimal, and negative sign).\n        * replaces the field names in the equation string with the actual field value (stripped to digits,\n            decimal, and negative sign).\n        * strips all whitespace out of equation\n        * runs equation through parser\n        * format result with proper thousand, decimal, and currency values\n        * update result field with formatted result value\n        * potentially trigger chain reaction calculations if necessary\n*/\nexport function autoCalc(eq: string, fields: IField[], result: JQuery, ctx: JQuery, opts: IOptions, vars: IVars, funcs: IFunctions) {\n    let resultValue = '';\n    const numberFormat: INumberFormat = {\n        dec: '',\n        decPlaces: -1,\n        thou: '',\n        sym: '',\n        symLoc: -1\n    };\n\n    $.each($.extend({}, funcs), function(func, f) {\n        const r = new RegExp(f.rgx, 'gi');\n        let m: RegExpMatchArray;\n\n        while ((m = r.exec(eq)) != null) {\n            const v = f.exec(m[1], ctx, opts, numberFormat);\n            eq = eq.replace(new RegExp(f.rgx, 'gi'), v);\n        }\n    });\n\n    for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const fieldValue = $(getFieldSelector(field.fieldName), ctx).val();\n\n        const numValue = numCleanse(fieldValue, opts, numberFormat);\n        if (numValue.length == 0) {\n            result.val('').trigger(\"change\");\n            return;\n        }\n\n        const parsedValue = parse(numValue, {showParseError: false});\n        if (parsedValue == null) {\n\t\t\tresult.val('').trigger(\"change\");\n\t\t\treturn;\n\t\t}\n\n        eq = eq.replace(new RegExp('{' + field.eqName + '}', 'g'), numValue);\n    }\n    eq = eq.replace(/ /g, '');\n\n    if (numberFormat.dec == '') {\n        numberFormat.dec = opts.decimalOpts[0];\n    }\n    if (numberFormat.decPlaces == -1) {\n        numberFormat.decPlaces = 0;\n    }\n    if (numberFormat.thou == '') {\n        numberFormat.thou = opts.thousandOpts[0];\n    }\n\n    const tmp = parse(eq, opts);\n    if (tmp == null) {\n        resultValue = '';\n    } else {\n        resultValue = numberFix(tmp, numberFormat.decPlaces);\n    }\n\n    resultValue = resultValue.replace(/\\./g, '<c>');\n    resultValue = resultValue.replace(/\\,/g, '<t>');\n    resultValue = resultValue.replace(/<c>/g, numberFormat.dec);\n    resultValue = resultValue.replace(/<t>/g, numberFormat.thou);\n    if (numberFormat.symLoc > -1) {\n        if (numberFormat.symLoc == 0) {\n            resultValue = numberFormat.sym + resultValue;\n        } else {\n            resultValue = resultValue + numberFormat.sym;\n        }\n    }\n\n    if (opts.smartIntegers) {\n        resultValue = resultValue.replace(/[\\,\\.]0+$/, '');\n    }\n    if (typeof opts.onShowResult === \"function\") {\n        resultValue = opts.onShowResult.call(result, resultValue);\n    }\n\n    result.val(resultValue);\n    if (opts.chainFire) {\n        const current = result.data('current');\n\n        if (current === undefined || current !== resultValue) {\n            result.data('current', resultValue);\n            result.trigger(\"change\");\n        }\n    }\n}\n","import { findFields, getFieldSelector } from './utils';\nimport { autoCalc } from './autocalc';\nimport { IOptions, IVars, IFunctions } from './interfaces';\n\nconst NAMESPACE = 'jautocalc';\nconst TAG = '_' + NAMESPACE;\nlet EVENTS = 'focus change blur'\n\nexport function init(jq: JQuery, opts: IOptions, vars: IVars, funcs: IFunctions): JQuery {\n    return jq.each(function (this: HTMLElement) {\n        const $ctx = $(this);\n        $('[' + opts.attribute + ']:not([' + TAG + '])', $ctx).each(function (this: HTMLElement) {\n            const $this = $(this);\n            const eq = $this.attr(opts.attribute);\n            const fields = findFields(eq);\n\n            if (fields.length == 0) {\n                return;\n            }\n\n            for (let i = 0; i < fields.length; i++) {\n                if ($(getFieldSelector(fields[i].fieldName), $ctx).length == 0) {\n                    return;\n                }\n            }\n\n            if (opts.keyEventsFire) {\n                EVENTS += ' keyup keydown keypress';\n            }\n\n            const fireEvents = EVENTS\n\t\t\t\t.split(' ')\n\t\t\t\t.map(w => `${w}.${NAMESPACE}`)\n\t\t\t\t.join('.' + NAMESPACE + ' ');\n\n            for (let i = 0; i < fields.length; i++) {\n                const field = fields[i];\n                if (field.reactive === false) continue;\n                $(getFieldSelector(field.fieldName), $ctx).on(fireEvents, {\n                    equation: eq,\n                    equationFields: fields,\n                    result: $this,\n                    context: $ctx,\n                    opts: opts,\n                    vars: vars,\n                    funcs: funcs\n                }, function (e) {\n                    autoCalc(e.data.equation, e.data.equationFields, e.data.result, e.data.context, e.data.opts, e.data.vars, e.data.funcs);\n                });\n            }\n            if (opts.readOnlyResults) {\n                $this.attr('readonly', 'readonly');\n            }\n            $this.attr(TAG, TAG);\n            if (opts.initFire) {\n                $(getFieldSelector(fields[0].fieldName), $ctx).trigger(\"change\");\n            }\n        });\n    });\n}\n\nexport function destroy(jq: JQuery, opts: IOptions): JQuery {\n    return jq.each(function (this: HTMLElement) {\n        const $ctx = $(this);\n        $('[' + opts.attribute + '][' + TAG + ']', $ctx).each(function (this: HTMLElement) {\n            const $this = $(this);\n            const eq = $this.attr(opts.attribute);\n            const fields = findFields(eq);\n            if (fields.length == 0) {\n                return;\n            }\n            for (let i = 0; i < fields.length; i++) {\n                const field = fields[i];\n                $(getFieldSelector(field.fieldName), $ctx).off('.' + NAMESPACE);\n            }\n            if (opts.readOnlyResults) {\n                $this.removeAttr('readonly');\n            }\n            $this.removeAttr(TAG);\n        });\n    });\n}\n","import $ from 'jquery';\nimport { INumberFormat, IFunctions, IOptions } from \"./interfaces\";\nimport { getFieldSelector, numCleanse} from './utils'\n\nexport const funcs: IFunctions = {\n    'sum': {\n        rgx: 'sum\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\n            let m = 0;\n            $(getFieldSelector(field), ctx).each(function () {\n                const n = parseFloat(numCleanse($(this).val(), opts, numberFormat));\n                m += n;\n            });\n            return m;\n        }\n    },\n    'avg': {\n        rgx: 'avg\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\n            let m = 0;\n            const c = $(getFieldSelector(field), ctx).each(function () {\n                const n = parseFloat(numCleanse($(this).val(), opts, numberFormat));\n                m += n;\n            }).length;\n            return m / c;\n        }\n    },\n    'min': {\n        rgx: 'min\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\n            return Math.min.apply(this, $(getFieldSelector(field), ctx).map(function (i, e) {\n                return numCleanse($(e).val(), opts, numberFormat);\n            }).get());\n        }\n    },\n    'max': {\n        rgx: 'max\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\n            return Math.max.apply(this, $(getFieldSelector(field), ctx).map(function (i, e) {\n                return numCleanse($(e).val(), opts, numberFormat);\n            }).get());\n        }\n    },\n    'count': {\n        rgx: 'count\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery): number {\n            return $(getFieldSelector(field), ctx).length;\n        }\n    },\n    'countNotEmpty': {\n        rgx: 'countNotEmpty\\\\({([^}]+)}\\\\)',\n        exec: function (field: string, ctx: JQuery): number {\n            return $.grep($(getFieldSelector(field), ctx), function (n) {\n                const val = $(n).val() + '';\n                return val.length > 0;\n            }).length;\n        }\n    }\n}\n","/*\n    jAutoCalc.js\n    Copyright (c) 2010 Christian Sauer\n    see LICENSE for details\n*/\nimport $ from 'jquery';\nimport { init, destroy } from './admin';\nimport { funcs } from './functions';\nimport { vars } from './parse';\n\n$.fn.jAutoCalc = Object.assign<JAutoCalcFunction, JAutoCalcDefaults>(\n    function (this: JQuery, ...args:any[]): JQuery {\n\n        let method = 'init'\n        let o = $.extend({}, $.fn.jAutoCalc.defaults);\n        const publicMethods: { [name: string]: Function } = {\n            init: init,\n            destroy: destroy\n        };\n\n        for(const arg of args) {\n            if (typeof arg  === 'string') {\n                method = arg.toString();\n            }\n            if (typeof arg === 'object') {\n                o = $.extend(o, arg);\n            }\n        }\n\n        const f = $.extend({}, funcs, o.funcs);\n        const v = $.extend([], vars, o.vars);\n\n        if (publicMethods[method]) {\n            return publicMethods[method](this, o, v, f);\n        } else {\n            return init(this, o, v, f);\n        }\n    },\n    {\n        defaults: {\n            attribute: 'jAutoCalc',\n            thousandOpts: [',', '.', ' '],\n            decimalOpts: ['.', ','],\n            decimalPlaces: -1,\n            initFire: true,\n            chainFire: true,\n            keyEventsFire: false,\n            readOnlyResults: true,\n            showParseError: true,\n            emptyAsZero: false,\n            smartIntegers: false,\n            onShowResult: null,\n            funcs: {},\n            vars: {}\n        }\n    }\n);\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","jQuery","findFields","eq","m","fields","r","exec","field","eqName","fieldName","reactive","substr","push","getFieldSelector","test","numCleanse","value","opts","numberFormat","fieldValue","sepOpts","decimalOpts","concat","thousandOpts","numOpts","numValue","ch","dec","decLoc","thou","sym","symLoc","decPlaces","z","length","charAt","decimalPlaces","arguments","emptyAsZero","ops","op","precedence","assoc","l","Math","pow","vars","e","exp","pi","atan2","parseVal","match","startOffset","offset","indexOf","string","parseFloat","negate","parseExpr","error","Error","name","parseOp","stack","tos","pop","parse","str","showParseError","alert","autoCalc","result","ctx","funcs","resultValue","$","each","extend","func","f","RegExp","rgx","v","replace","i","val","trigger","tmp","num","x","toFixed","split","x2","x1","numberFix","smartIntegers","onShowResult","chainFire","current","data","undefined","NAMESPACE","TAG","EVENTS","init","jq","$ctx","this","attribute","$this","attr","keyEventsFire","fireEvents","map","w","join","on","equation","equationFields","context","readOnlyResults","initFire","destroy","off","removeAttr","n","c","min","apply","max","assign","method","publicMethods","args","arg","toString","defaults"],"sourceRoot":""}
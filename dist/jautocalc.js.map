{"version":3,"sources":["webpack://jautocalc/webpack/bootstrap","webpack://jautocalc/webpack/runtime/compat get default export","webpack://jautocalc/webpack/runtime/define property getters","webpack://jautocalc/webpack/runtime/hasOwnProperty shorthand","webpack://jautocalc/external \"jQuery\"","webpack://jautocalc/./src/utils.ts","webpack://jautocalc/./src/parse.ts","webpack://jautocalc/./src/autocalc.ts","webpack://jautocalc/./src/admin.ts","webpack://jautocalc/./src/functions.ts","webpack://jautocalc/./src/index.ts"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","jQuery","findFields","eq","m","fields","r","exec","push","getFieldSelector","field","test","numCleanse","value","opts","numberFormat","fieldValue","sepOpts","decimalOpts","concat","thousandOpts","numOpts","numValue","ch","dec","decLoc","thou","sym","symLoc","decPlaces","z","length","charAt","decimalPlaces","arguments","emptyAsZero","ops","op","precedence","assoc","l","Math","pow","vars","e","exp","pi","atan2","parseVal","match","startOffset","offset","indexOf","string","substr","parseFloat","negate","parseExpr","error","Error","name","parseOp","stack","tos","pop","parse","str","showParseError","alert","autoCalc","result","ctx","funcs","resultValue","$","each","extend","func","f","RegExp","rgx","v","replace","i","val","trigger","tmp","num","x","toFixed","split","x2","x1","numberFix","smartIntegers","onShowResult","chainFire","current","data","undefined","TAG","EVENTS","init","jq","$ctx","this","attribute","$this","attr","keyEventsFire","fireEvents","join","on","equation","equationFields","context","readOnlyResults","initFire","destroy","off","removeAttr","n","c","min","apply","map","max","assign","method","publicMethods","args","arg","toString","defaults"],"mappings":"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","file":"/jautocalc.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = jQuery;","import $ from 'jquery';\r\nimport { INumberFormat, IOptions } from './interfaces';\r\n\r\n/**\r\n *\r\n * @param eq {string} equation\r\n * @returns {string[]} field names in equation or empty list\r\n */\r\nexport function findFields(eq: string): string[] {\r\n    const fields = [];\r\n    const r = /{([^}]+)}/gi;\r\n    let m: RegExpMatchArray;\r\n\r\n    while ((m = r.exec(eq)) != null) {\r\n        fields.push(m[1]);\r\n    }\r\n\r\n    return fields;\r\n}\r\n\r\n/**\r\n *\r\n * @param field {string} field name\r\n * @returns {string} jquery input selector\r\n */\r\nexport function getFieldSelector(field: string): string {\r\n    if (/^[a-zA-Z].*/.test(field)) {\r\n        return ':input[name=\"' + field + '\"]';\r\n    }\r\n    return field;\r\n}\r\n\r\n/**\r\n *\r\n * @param value {string | number | string[]} field value from input control\r\n * @param opts {IOptions} options to decide decimal and thousands separators\r\n * @param numberFormat {INumberFormat} formatted values to be used later\r\n */\r\nexport function numCleanse(value: string | number | string[], opts: IOptions, numberFormat: INumberFormat): string {\r\n    const fieldValue = value + '';\r\n    const sepOpts = opts.decimalOpts.concat(opts.thousandOpts);\r\n    const numOpts = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-'];\r\n    let numValue = '';\r\n    let ch = '';\r\n    let dec = '';\r\n    let decLoc = -1;\r\n    let thou = '';\r\n    let sym = '';\r\n    let symLoc = -1;\r\n    let decPlaces = 0;\r\n\r\n    for (let z = fieldValue.length - 1; z >= 0; z--) {\r\n        ch = fieldValue.charAt(z);\r\n        if ($.inArray(ch, numOpts) != -1) {\r\n            numValue = ch + numValue;\r\n        } else {\r\n            if (dec == '' && $.inArray(ch, opts.decimalOpts) != -1) {\r\n                decLoc = z;\r\n                dec = ch;\r\n                numValue = '.' + numValue;\r\n            } else if (thou == '' && $.inArray(ch, opts.thousandOpts) != -1) {\r\n                thou = ch;\r\n            } else if (sym == '' && $.inArray(ch, sepOpts) == -1 && (z == 0 || z == fieldValue.length - 1)) {\r\n                sym = ch;\r\n                symLoc = z;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (dec != '') {\r\n        decPlaces = fieldValue.length - decLoc - 1;\r\n        if (symLoc > decLoc) {\r\n            decPlaces--;\r\n        }\r\n    }\r\n\r\n    if (opts.decimalPlaces != -1) {\r\n        decPlaces = opts.decimalPlaces;\r\n    }\r\n\r\n    if (arguments.length === 3) {\r\n        if (numberFormat.dec == '' && dec != '') {\r\n            numberFormat.dec = dec;\r\n        }\r\n\r\n        if ((numberFormat.decPlaces == -1 && decPlaces != -1) ||\r\n            (numberFormat.decPlaces != -1 && decPlaces != -1 && decPlaces < numberFormat.decPlaces)) {\r\n            numberFormat.decPlaces = decPlaces;\r\n        }\r\n\r\n        if (numberFormat.thou == '' && thou != '') {\r\n            numberFormat.thou = thou;\r\n        }\r\n        if (numberFormat.sym == '' && sym != '') {\r\n            numberFormat.sym = sym;\r\n            numberFormat.symLoc = symLoc;\r\n        }\r\n    }\r\n\r\n    if (opts.emptyAsZero && numValue == '') {\r\n        numValue = '0';\r\n    }\r\n    return numValue;\r\n}\r\n\r\n/*\r\n    Takes a numeric value, \"fixes\" it to the specified number of decimal places, and then formats for typical\r\n    US format (\",\" for thousands and \".\" for decimal)\r\n*/\r\nexport function numberFix(num: number, decPlaces: number): string {\r\n    const n = num.toFixed(decPlaces) + '';\r\n    const x = n.split('.');\r\n    const x2 = x.length > 1 ? '.' + x[1] : '';\r\n    const rgx = /(\\d+)(\\d{3})/;\r\n    let x1 = x[0];\r\n    while (rgx.test(x1)) {\r\n        x1 = x1.replace(rgx, '$1' + ',' + '$2');\r\n    }\r\n    return x1 + x2;\r\n}\r\n","/*\n    Begin parse functions\n    Taken from\n        * http://stackoverflow.com/questions/28256/equation-expression-parser-with-precedence\n        * http://users.telenet.be/bartl/expressionParser/expressionParser.html\n*/\nimport { IData, IOperation, IOperations, IVars, IOptions } from './interfaces';\n\nconst ops: IOperations = {\n    '+': {\n        op: '+',\n        precedence: 10,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l + r;\n        }\n    },\n    '-': {\n        op: '-',\n        precedence: 10,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l - r;\n        }\n    },\n    '*': {\n        op: '*',\n        precedence: 20,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l * r;\n        }\n    },\n    '/': {\n        op: '/',\n        precedence: 20,\n        assoc: 'L',\n        exec: function (l: number, r: number) {\n            return l / r;\n        }\n    },\n    '**': {\n        op: '**',\n        precedence: 30,\n        assoc: 'R',\n        exec: function (l: number, r: number) {\n            return Math.pow(l, r);\n        }\n    }\n};\n\nexport const vars: IVars = {\n    e: Math.exp(1),\n    pi: Math.atan2(1, 1) * 4\n};\n\nfunction parseVal(r: IData): number {\n    const startOffset: number = r.offset;\n    let value: number;\n    let match: RegExpMatchArray;\n    // floating point number\n    // example of parsing (\"lexing\") without aid of regular expressions\n    value = 0;\n    while ('0123456789'.indexOf(r.string.substr(r.offset, 1)) >= 0 && r.offset < r.string.length) {\n        r.offset++;\n    }\n    if (r.string.substr(r.offset, 1) == '.') {\n        r.offset++;\n        while ('0123456789'.indexOf(r.string.substr(r.offset, 1)) >= 0 && r.offset < r.string.length) {\n            r.offset++;\n        }\n    }\n    if (r.offset > startOffset) { // did that work?\n        // OK, so I'm lazy...\n        return parseFloat(r.string.substr(startOffset, r.offset - startOffset));\n    } else if (r.string.substr(r.offset, 1) == '+') { // unary plus\n        r.offset++;\n        return parseVal(r);\n    } else if (r.string.substr(r.offset, 1) == '-') { // unary minus\n        r.offset++;\n        return negate(parseVal(r));\n    } else if (r.string.substr(r.offset, 1) == '(') { // expression in parens\n        r.offset++; // eat \"(\"\n        value = parseExpr(r);\n        if (r.string.substr(r.offset, 1) == ')') {\n            r.offset++;\n            return value;\n        }\n        r.error = \"Parsing error: ')' expected\";\n        throw new Error('parseError');\n    } else if ((match = /^[a-z_][a-z0-9_]*/i.exec(r.string.substr(r.offset))) != null) { // variable/constant name\n        // sorry for the regular expression, but I'm too lazy to manually build a varname lexer\n        const name = match[0]; // matched string\n        r.offset += name.length;\n        if (name in vars) {\n            return vars[name]; // I know that thing!\n        }\n        r.error = \"Semantic error: unknown variable '\" + name + \"'\";\n        throw new Error('unknownVar');\n    } else {\n        if (r.string.length == r.offset) {\n            r.error = 'Parsing error at end of string: value expected';\n            throw new Error('valueMissing');\n        } else {\n            r.error = \"Parsing error: unrecognized value\";\n            throw new Error('valueNotParsed');\n        }\n    }\n}\n\nfunction negate(value: number): number {\n    return -value;\n}\n\nfunction parseOp(r: IData) {\n    if (r.string.substr(r.offset, 2) == '**') {\n        r.offset += 2;\n        return ops['**'];\n    }\n    if ('+-*/'.indexOf(r.string.substr(r.offset, 1)) >= 0) {\n        return ops[r.string.substr(r.offset++, 1)];\n    }\n    return null;\n}\n\nfunction parseExpr(r: IData) {\n    const stack: IOperation[] = [{\n        precedence: 0,\n        assoc: 'L'\n    }];\n    let value = parseVal(r); // first value on the left\n    for (; ;) {\n        const op = parseOp(r) || {\n            precedence: 0,\n            assoc: 'L'\n        };\n        while (op.precedence < stack[stack.length - 1].precedence ||\n            (op.precedence == stack[stack.length - 1].precedence && op.assoc == 'L')) {\n            // precedence op is too low, calculate with what we've got on the left, first\n            const tos = stack.pop();\n            if (!tos.exec) {\n                return value; // end  reached\n            }\n            // do the calculation (\"reduce\"), producing a new value\n            value = tos.exec(tos.value, value);\n        }\n        // store on stack and continue parsing (\"shift\")\n        stack.push({\n            op: op.op,\n            precedence: op.precedence,\n            assoc: op.assoc,\n            exec: op.exec,\n            value: value\n        });\n        value = parseVal(r); // value on the right\n    }\n}\n\nexport function parse(str: string, opts: IOptions): number | null {\n    const r: IData = {\n        string: str,\n        offset: 0\n    };\n    try {\n        const value = parseExpr(r);\n        if (r.offset < r.string.length) {\n            r.error = 'Syntax error: junk found at offset ' + r.offset;\n            throw new Error('trailingJunk');\n        }\n        return value;\n    } catch (e) {\n        if (opts.showParseError) {\n            alert(`${r.error} (${e}):\\n${r.string.substr(0, r.offset)}<*>${r.string.substr(r.offset)}`);\n        }\n        return null;\n    }\n}\n","import { parse } from './parse';\nimport { INumberFormat, IOptions, IVars, IFunctions } from './interfaces';\nimport { getFieldSelector, numCleanse, numberFix } from './utils';\n\n/*\n    Heart of the plugin:\n        * replaces aggregate functions in the equation string with the result of the aggregate function\n            (stripped to digits, decimal, and negative sign).\n        * replaces the field names in the equation string with the actual field value (stripped to digits,\n            decimal, and negative sign).\n        * strips all whitespace out of equation\n        * runs equation through parser\n        * format result with proper thousand, decimal, and currency values\n        * update result field with formatted result value\n        * potentially trigger chain reaction calculations if necessary\n*/\nexport function autoCalc(eq: string, fields: string[], result: JQuery, ctx: JQuery, opts: IOptions, vars: IVars, funcs: IFunctions) {\n    let resultValue = '';\n    const numberFormat: INumberFormat = {\n        dec: '',\n        decPlaces: -1,\n        thou: '',\n        sym: '',\n        symLoc: -1\n    };\n\n    $.each($.extend({}, funcs), function(func, f) {\n        const r = new RegExp(f.rgx, 'gi');\n        let m: RegExpMatchArray;\n\n        while ((m = r.exec(eq)) != null) {\n            const v = f.exec(m[1], ctx, opts, numberFormat);\n            eq = eq.replace(new RegExp(f.rgx, 'gi'), v);\n        }\n    });\n\n    for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const fieldValue = $(getFieldSelector(field), ctx).val();\n\n        const numValue = numCleanse(fieldValue, opts, numberFormat);\n        if (numValue.length == 0) {\n            result.val('').trigger(\"change\");\n            return;\n        }\n\n        const parsedValue = parse(numValue, {showParseError: false});\n        if (parsedValue == null) {\n\t\t\tresult.val('').trigger(\"change\");\n\t\t\treturn;\n\t\t}\n\n        eq = eq.replace(new RegExp('{' + field + '}', 'g'), numValue);\n    }\n    eq = eq.replace(/ /g, '');\n\n    if (numberFormat.dec == '') {\n        numberFormat.dec = opts.decimalOpts[0];\n    }\n    if (numberFormat.decPlaces == -1) {\n        numberFormat.decPlaces = 0;\n    }\n    if (numberFormat.thou == '') {\n        numberFormat.thou = opts.thousandOpts[0];\n    }\n\n    const tmp = parse(eq, opts);\n    if (tmp == null) {\n        resultValue = '';\n    } else {\n        resultValue = numberFix(tmp, numberFormat.decPlaces);\n    }\n\n    resultValue = resultValue.replace(/\\./g, '<c>');\n    resultValue = resultValue.replace(/\\,/g, '<t>');\n    resultValue = resultValue.replace(/<c>/g, numberFormat.dec);\n    resultValue = resultValue.replace(/<t>/g, numberFormat.thou);\n    if (numberFormat.symLoc > -1) {\n        if (numberFormat.symLoc == 0) {\n            resultValue = numberFormat.sym + resultValue;\n        } else {\n            resultValue = resultValue + numberFormat.sym;\n        }\n    }\n\n    if (opts.smartIntegers) {\n        resultValue = resultValue.replace(/[\\,\\.]0+$/, '');\n    }\n    if (typeof opts.onShowResult === \"function\") {\n        resultValue = opts.onShowResult.call(result, resultValue);\n    }\n\n    result.val(resultValue);\n    if (opts.chainFire) {\n        const current = result.data('current');\n\n        if (current === undefined || current !== resultValue) {\n            result.data('current', resultValue);\n            result.trigger(\"change\");\n        }\n    }\n}\n","import { findFields, getFieldSelector } from './utils';\nimport { autoCalc } from './autocalc';\nimport { IOptions, IVars, IFunctions } from './interfaces';\n\nconst NAMESPACE = 'jautocalc';\nconst TAG = '_' + NAMESPACE;\nlet EVENTS = 'focus change blur'\n\nexport function init(jq: JQuery, opts: IOptions, vars: IVars, funcs: IFunctions): JQuery {\n    return jq.each(function (this: HTMLElement) {\n        const $ctx = $(this);\n        $('[' + opts.attribute + ']:not([' + TAG + '])', $ctx).each(function (this: HTMLElement) {\n            const $this = $(this);\n            const eq = $this.attr(opts.attribute);\n            const fields = findFields(eq);\n\n            if (fields.length == 0) {\n                return;\n            }\n\n            for (let i = 0; i < fields.length; i++) {\n                if ($(getFieldSelector(fields[i]), $ctx).length == 0) {\n                    return;\n                }\n            }\n\n            if (opts.keyEventsFire) {\n                EVENTS += ' keyup keydown keypress';\n            }\n\n            const fireEvents = EVENTS.split(' ').join('.' + NAMESPACE + ' ');\n\n            for (let i = 0; i < fields.length; i++) {\n                const field = fields[i];\n                $(getFieldSelector(field), $ctx).on(fireEvents, {\n                    equation: eq,\n                    equationFields: fields,\n                    result: $this,\n                    context: $ctx,\n                    opts: opts,\n                    vars: vars,\n                    funcs: funcs\n                }, function (e) {\n                    autoCalc(e.data.equation, e.data.equationFields, e.data.result, e.data.context, e.data.opts, e.data.vars, e.data.funcs);\n                });\n            }\n            if (opts.readOnlyResults) {\n                $this.attr('readonly', 'readonly');\n            }\n            $this.attr(TAG, TAG);\n            if (opts.initFire) {\n                $(getFieldSelector(fields[0]), $ctx).trigger(\"change\");\n            }\n        });\n    });\n}\n\nexport function destroy(jq: JQuery, opts: IOptions): JQuery {\n    return jq.each(function (this: HTMLElement) {\n        const $ctx = $(this);\n        $('[' + opts.attribute + '][' + TAG + ']', $ctx).each(function (this: HTMLElement) {\n            const $this = $(this);\n            const eq = $this.attr(opts.attribute);\n            const fields = findFields(eq);\n            if (fields.length == 0) {\n                return;\n            }\n            for (let i = 0; i < fields.length; i++) {\n                const field = fields[i];\n                $(getFieldSelector(field), $ctx).off('.' + NAMESPACE);\n            }\n            if (opts.readOnlyResults) {\n                $this.removeAttr('readonly');\n            }\n            $this.removeAttr(TAG);\n        });\n    });\n}\n","import $ from 'jquery';\r\nimport { INumberFormat, IFunctions, IOptions } from \"./interfaces\";\r\nimport { getFieldSelector, numCleanse} from './utils'\r\n\r\nexport const funcs: IFunctions = {\r\n    'sum': {\r\n        rgx: 'sum\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\r\n            let m = 0;\r\n            $(getFieldSelector(field), ctx).each(function () {\r\n                const n = parseFloat(numCleanse($(this).val(), opts, numberFormat));\r\n                m += n;\r\n            });\r\n            return m;\r\n        }\r\n    },\r\n    'avg': {\r\n        rgx: 'avg\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\r\n            let m = 0;\r\n            const c = $(getFieldSelector(field), ctx).each(function () {\r\n                const n = parseFloat(numCleanse($(this).val(), opts, numberFormat));\r\n                m += n;\r\n            }).length;\r\n            return m / c;\r\n        }\r\n    },\r\n    'min': {\r\n        rgx: 'min\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\r\n            return Math.min.apply(this, $(getFieldSelector(field), ctx).map(function (i, e) {\r\n                return numCleanse($(e).val(), opts, numberFormat);\r\n            }).get());\r\n        }\r\n    },\r\n    'max': {\r\n        rgx: 'max\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery, opts: IOptions, numberFormat: INumberFormat): number {\r\n            return Math.max.apply(this, $(getFieldSelector(field), ctx).map(function (i, e) {\r\n                return numCleanse($(e).val(), opts, numberFormat);\r\n            }).get());\r\n        }\r\n    },\r\n    'count': {\r\n        rgx: 'count\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery): number {\r\n            return $(getFieldSelector(field), ctx).length;\r\n        }\r\n    },\r\n    'countNotEmpty': {\r\n        rgx: 'countNotEmpty\\\\({([^}]+)}\\\\)',\r\n        exec: function (field: string, ctx: JQuery): number {\r\n            return $.grep($(getFieldSelector(field), ctx), function (n) {\r\n                const val = $(n).val() + '';\r\n                return val.length > 0;\r\n            }).length;\r\n        }\r\n    }\r\n}\r\n","/*\r\n    jAutoCalc.js\r\n    Copyright (c) 2010 Christian Sauer\r\n    see LICENSE for details\r\n*/\r\nimport $ from 'jquery';\r\nimport { init, destroy } from './admin';\r\nimport { funcs } from './functions';\r\nimport { vars } from './parse';\r\n\r\n$.fn.jAutoCalc = Object.assign<JAutoCalcFunction, JAutoCalcDefaults>(\r\n    function (this: JQuery, ...args:any[]): JQuery {\r\n\r\n        let method = 'init'\r\n        let o = $.extend({}, $.fn.jAutoCalc.defaults);\r\n        const publicMethods: { [name: string]: Function } = {\r\n            init: init,\r\n            destroy: destroy\r\n        };\r\n\r\n        for(const arg of args) {\r\n            if (typeof arg  === 'string') {\r\n                method = arg.toString();\r\n            }\r\n            if (typeof arg === 'object') {\r\n                o = $.extend(o, arg);\r\n            }\r\n        }\r\n\r\n        const f = $.extend({}, funcs, o.funcs);\r\n        const v = $.extend([], vars, o.vars);\r\n\r\n        if (publicMethods[method]) {\r\n            return publicMethods[method](this, o, v, f);\r\n        } else {\r\n            return init(this, o, v, f);\r\n        }\r\n    },\r\n    {\r\n        defaults: {\r\n            attribute: 'jAutoCalc',\r\n            thousandOpts: [',', '.', ' '],\r\n            decimalOpts: ['.', ','],\r\n            decimalPlaces: -1,\r\n            initFire: true,\r\n            chainFire: true,\r\n            keyEventsFire: false,\r\n            readOnlyResults: true,\r\n            showParseError: true,\r\n            emptyAsZero: false,\r\n            smartIntegers: false,\r\n            onShowResult: null,\r\n            funcs: {},\r\n            vars: {}\r\n        }\r\n    }\r\n);\r\n"],"sourceRoot":""}